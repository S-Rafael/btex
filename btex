#!/bin/bash

###   This program is used to  compile latex files and output ps/pdf files  ###

        ###                     Changelog                         ###
        # 12/25/2007    Allow one to execute it by clicking on the  #
        #               file in rox                                 #
        #               Better help text                            #
        # 12/20/2007    Amazing article online enables me to get    #
        #               the status of each part of a pipe, so now   #
        #               error checking works very nice even with    #
        #               the grep command (in QUIET mode)            #
        # 11/24/2007    Rudimentary autocompile mode                #
        # 11/20/2007    Pretty output :P                            #
        #               New pattern for grep to capture more errors #
        # 10/10/2007    Enabled a quiet mode (reduces junk o/p)     #
        #               Enabled Toggling the quiet mode             #
        #               Reorganized menu and help text              #
        # 04/28/2007    Enabled method to convert ps to pdf         #
        # 02/??/2007    Enabled an option to support beamer         #
        # 01/??/2007    Enabled a "non-stop" mode                   #
        # <=01/01/2007  Umpteen number of untracked changes         #
        #-----------------------------------------------------------#

        ###                         TODO (04/28/2007)             ###
        # Enable a quiet mode, where only latex errors are shown    #
        #   need to look into --interaction nonstopmode             #
        #   and make the latex compilation handling more modular    #
        # The above is done, but without --interaction nonstopmode  #
        # would be interesting to see if it can be improved.        #
        #                                                           #
        # Enable an auto mode, where the latex file will be         #
        # automatically compiled whenever the timestamp of the tex  #
        # file changes.                                             #
        #-----------------------------------------------------------#

###   Set the colors that will be used   ### {{{
yellow="\E[1;33m"
red="\E[1;31m"
green="\E[1;32m"
underline="\E[4m"
bold="\E[1m"
normal="\E[0m"


# Print out information.
# Usage: info "Whatever you want to print"
info(){
    echo -e "  $yellow *$normal   ${@}";
}

# Print out information without ending with a newline. This adds a space at end
# Usage: infon "Whatever you want to print"
infon(){
    echo -ne "  $yellow *$normal   ${@} ";
}

# Print out error information.
# Usage: Err "Whatever you want to print"
Err(){
    echo -e "  $red *$normal   [$red ERROR!!$normal ] ${@}" >&2;
}

die() {
    Err "$@";
    exit 1;
}
# }}}

DVIPS_PAPER_OPTIONS="-tletter";
PS_VIEWER="gv -watch -spartan"
DVI_VIEWER="xdvi"
PDF_VIEWER="xpdf"
RECURSIVE=0;
PREV_MODE=;
NON_STOP=;
QUIET=;
COUNT=1;
# Possible modes: POSTSCRIPT, ASK_POSTSCRIPT, NO_POSTSCRIPT, PDF : Default is below
MODE="ASK_POSTSCRIPT"; 

help(){ #{{{
    echo;
    echo -e "  $yellow $( basename ${0} ):$normal";
    info "This program is used to compile latex files and output ps/pdf files"
    info "Usage:     $( basename ${0} ) [<options>] [<filename>.tex]";
    info "Options:"
    info "-a | --acroread        Use acrobat reader as pdf viewer in lieu of xpdf"
    info "-b | --beamer          Beamer mode: disable -tletter option in dvips"
    info "-d | --pdf             Output a pdf file,- this uses pdflatex";
    info "-h | --help            This help text";
    info "-n | --no-postscript   Do not output postscript file";
    info "-nc| --no-color        Do not use color in output";
    info "-ns| --non-stop        Do not exit program even if latex gives errors"
    info "-p | --postscript      Assume \"yes\" for postscript output";
    info "-q | --quiet           Do not print all the output latex spews out"
    info "-r | --recursive       Recursively compile the source";
    echo;
    info "If no filename is given, then an interactive input prompt is provided
    ${underline}An example, when using beamer${normal}:
    btex -b -d -r -q -ns # recursive, quiet, nonstop, using pdflatex & beamer";
    echo;
} #}}}


help_read_filename() { #{{{
    info "readfilename -h|--help: == help!!"
    info "readfilename <0|1> [<suffix>]"
    info "${red}BUG!${normal} If a dir is named foo and a file is named fool.bar, then you can enter foo by typing 'foo/.'"
    info "I know how to fix this bug, but it renders the code clumsy and so I won't do it ;)"
    info "Examples of Usage:"
    info "Eg. readfilename 1 tex  == match .tex files in any directory"
    info "Eg. readfilename 0 tex  == match .tex files in current directory only"
    info "Eg. readfilename 0      == match any file in current directory only"
}

## Usage read_filename <0|1> [<suffix>]  -- example: read_filename 1 ogg
read_filename() {
    
    [[ $# -eq 0 ]] && help_read_filename && exit 1;

    ## Declare the following variables
    local filename;
    local INPUT_X;
    local INPUT;
    global FILEPATH;
    local SUFFIX;
    ## Indicate whether we are recursing through directories
    local DIR=$1;
    [[ $# -eq 2 ]] && SUFFIX=".$2" || SUFFIX="";

    ## Remember the old pwd:
    local OLD_PWD=`pwd`
    

  ## Start of outer loop
  while [[ -z $filename || -d $filename ]];
  do
    [[ -d $filename ]] && cd $filename;


    ## Reinitialize all of these to null
    filename="";
    INPUT_X=;
    INPUT=;

    ## clear the screen -- the magic begins from here :)
    clear;
    
    ## Initial list of the file names found
    find ${INPUT_X}*${SUFFIX} -maxdepth 0 -type f -print 2>/dev/null  

    ## Initial list of directories + good looking output
    echo -ne "\n\n-----^^^^${green}Possible files$normal^^^^-----\n\n"
    [[ $DIR -eq 1 ]] && find ${INPUT_X}* -maxdepth 0 -type d -printf "%f\t\t" 2>/dev/null && \
    echo -e "\n\n-----^^^^${yellow}Possible directories${normal}^^^^-----\n\n"
    
    
    ## Do the loop until complete
    while true
    do
        # black on green  -- for completion part
        if [[ ! -z "$INPUT_X" ]]; then
            echo -ne "  $yellow *$normal   Enter the filename [${INPUT_X}\033[00;30;42m${EXT}$normal ?]: ${INPUT_X}"
        elif [[ $DIR -eq 1 ]]; then
            infon "Enter the filename (use .. to go up one directory):"
        else
            infon "Enter the filename:"
        fi

        ## Read each character as it is typed
        read -n 1 INPUT

        ## If input is null, then complete the rest of the stuff and dump it into $filename and exit from this loop
        if [[ -z "$INPUT" && ! -z "$INPUT_X" ]]; then
            filename="${INPUT_X}${EXT}";
            break;
        elif [[ -z "$INPUT" && -z "$INPUT_X" ]]; then
            Err "No filename provided";
            #help_read_filename;
            exit 1;
        fi

        ## else clear the screen for the next best matches
        clear;

        ## Whenever you press a backspace, it sends a non-printable character
        ## delete doesn't work since it sends three (!!) characters and read takes in only one
        if [[ -z `echo -e "$INPUT" | egrep  "[[:print:]]"` ]]; then
            ## If backspace was sent, delete the previous character
            INPUT_X=`echo ${INPUT_X} | head -c -2`
        else
            ## else append the current character to the extended input variable, $INPUT_X
            INPUT_X="${INPUT_X}${INPUT}"
        fi


        ## If the DIR variable is turned on, and we received a .., then go up one directory
        [[ $DIR -eq 1 && "$INPUT_X" = ".." ]] && cd .. && INPUT_X="" && FILEPATH=`pwd`;


        ## Find all the best matches to files and output them
        OUTPUT=`find ${INPUT_X}* -maxdepth 0 -type f -print 2>/dev/null | egrep "${SUFFIX}$"`;
        echo "${OUTPUT}"


        ## If the extended input is non-zero, then we need to find the extension to it.
        if [[ ! -z "${INPUT_X}" ]]; then
            ## If there are no matching files, and DIR is on, then complete dirs instead of files
            if [[ -z "${OUTPUT}" && $DIR -eq 1 ]]; then
                EXT=`find ${INPUT_X}* -maxdepth 0 -type d -print 2>/dev/null | sed -ne "1s:^${INPUT_X}\(.*\)$:\1:p"`
            else
                EXT=`echo "${OUTPUT}" | sed -ne "1s:^${INPUT_X}\(.*\)$:\1:p"`;
            fi
        fi

        ## Again need for some nicely formatted output
        echo -ne "\n\n-----^^^^${green}Possible files$normal^^^^-----\n\n"
        [[ $DIR -eq 1 ]] && find ${INPUT_X}* -maxdepth 0 -type d -printf "%f\t\t" 2>/dev/null && \
        echo -e "\n\n-----^^^^${yellow}Possible directories${normal}^^^^-----\n\n"
        
    done

    ## Completed inner loop, so $filename is either null or has some info in it.
    if [[ -z $FILEPATH ]]; then
        FILEPATH="$filename"
    else
        FILEPATH="$FILEPATH/$filename"
    fi
  done
  ## Completed outer loop here

    ## Return to the dir from which this function was called
    cd "$OLD_PWD"

} #}}}



check() {
    [[ ! -x `which $@` ]] && die "You don't seem to have $@ installed. Is your PATH setup correctly?";
    return 0;
}
    
#echo $-
[[ $DISPLAY && -z "$@" ]] && ! tty -s && ( xterm -hold -e $0 -h && exit )

if [[ -n "$@" ]]; then
    for i in "$@"
    do
        case $i in
        -h | --help)        help; exit; ;;
        -nc | --no-color)   unset yellow red green underline bold; ;;
        -ns | --non-stop)   NON_STOP=1; ;;
        -p | --postscript)
            if [[ "$MODE" = "NO_POSTSCRIPT" ]]; then 
                help; die "Can not give -p and -n options together\n";
            else    MODE="POSTSCRIPT";
            fi ;;
        -n | --no-postscript)
            if [[ "$MODE" = "POSTSCRIPT" ]]; then
                help; die "Can not give -p and -n options together\n";
            else    MODE="NO_POSTSCRIPT";
            fi ;;
        -d | --pdf)
            if [[ "$MODE" = "POSTSCRIPT" || "$MODE" = "NO_POSTSCRIPT" ]]; then
                help;  die "Can not give -p or -n, and -d options together\n";
            else check pdflatex && check epstopdf; MODE="PDF"
            fi ;;
        -r | --recursive)   RECURSIVE=1; ;;
        -b | --beamer)      DVIPS_PAPER_OPTIONS="";; 
        -a | --acroread)    PDF_VIEWER="acroread";;
        -q | --quiet)       QUIET=1;;
        -*)     help; die "${red}$i${normal}: Invalid Option!\n"; ;;
        *)      filename="$i"; ;;
        esac
    done
fi

show_menu() { # {{{
    echo; echo;
    info "Want to continue with another compile?\n
\tEnter/${green}Y${normal}: Yes\t\t\t\
${green}N${normal}: No\n\t\
${green}P${normal}: Toggle Postscript output\t\
${green}L${normal}: Launch ${PS_VIEWER%%\ *}\n\t\
${green}D${normal}: Toggle Pdf Output\t\t\
${green}X${normal}: Launch ${DVI_VIEWER}\n\t\
${green}2${normal}: Toggle PS to PDF output\t\
${green}F${normal}: Launch ${PDF_VIEWER}\n\t\
${green}Q${normal}: Toggle Quiet mode\t\t\
${green}A${normal}: Enable Autocompile mode"
    infon "Give an option ([Y]/N/P/D/L/X/Q/A):"
}
# }}}

compile_ps() { #{{{
    if [[ $QUIET ]]; then
        latex "${filename}"  >&1 | grep --color -A 11 '^! .*';
        # echo ${PIPESTATUS[@]} gives the exit status of each part of pipe
        [[ ${PIPESTATUS[0]} -ne 0 && -z "$NON_STOP" ]] && \
            die "${filename}: Error in latex compilation"; 
    else
        latex "${filename}"
        [[ $? -ne 0 && -z "$NON_STOP" ]] && \
            die "${filename}: Error in latex compilation"; 
    fi

    case $1 in
        ask)echo; infon "CONTINUE with dvips?[enter/y or n]:";
            read -n 1 answer;echo;;
        only_dvi) answer="n";;
        *)  answer="y";;
    esac
    case $answer in
        "" | [yY]*) infon "Creating $file.ps ... ";#echo;
            dvips ${DVIPS_PAPER_OPTIONS} -q -o "$file.ps" "$file.dvi"
            ([[ $? -ne 0 ]] && echo -e "${red}Failed!${normal}") ||\
                echo -e "${green}Done!${normal}";;
        *) ;; # Do nothing
    esac
} #}}}

compile_pdf() { # {{{
    info "Converting the (newer) eps images to pdf ..."
    find *.eps | while read i; do
        if [[ "${i%\.*}.pdf" -ot "$i" ]]; then
            infon "Converting ${bold}$i${normal} to ${bold}${i%\.*}.pdf${normal} ... "
            epstopdf $i --outfile="${i%\.*}.pdf"
            ([[ $? -ne 0 ]] && echo -e "${red}Failed!${normal}") ||\
                echo -e "${green}Done!${normal}"
        fi
    done
    if [[ "$QUIET" ]]; then
        pdflatex "${filename}" >&1 | grep --color -A 11 '^! .*' -;
        # echo ${PIPESTATUS[@]} gives the exit status of each part of pipe
        [[ ${PIPESTATUS[0]} -ne 0 && -z $NON_STOP ]] && \
            die "${filename}: pdflatex compilation failed"
    else
        pdflatex "$filename"
        [[ $? -ne 0 && -z $NON_STOP ]] && \
            die "${filename}: pdflatex compilation failed"
    fi
}
# }}}

# Some error checking
check latex;
[[ "$MODE" = "POSTSCRIPT" || "$MODE" = "ASK_POSTSCRIPT" ]] && check dvips && check "${PS_VIEWER%%\ *}";




if [[ -z ${filename} ]]; then
    read_filename 0 tex;
    filename="$FILEPATH";
    unset FILEPATH;
fi


if [[ ! -f "${filename}" || "${filename/ /}" != "${filename}" ]]; then
    echo; die "${filename} does not exist\n\tHint: Do not enter filenames with spaces in them\n";
fi

# Change to the directory containing the tex file, else a lot will go awry
cd "$(dirname "$filename")"
file="${filename%\.*}";

while true; do

    # The autocompile mode is basically a bad hack :(
    if [[ $MODE = "AUTO_COMPILE" && $PREV_MODE != "AUTO_COMPILE" ]]; then
        if inotifywait -t 300 -qq ${filename}; then
            info "Autocompile # $COUNT/5"
            MODE=$PREV_MODE; PREV_MODE=AUTO_COMPILE;
        else
            MODE=NO_COMPILE;
        fi
    elif [[ $PREV_MODE = "AUTO_COMPILE" ]]; then
        MODE=AUTO_COMPILE; PREV_MODE=; COUNT=1;
    fi

    case $MODE in
        ASK_POSTSCRIPT) compile_ps ask ;;
        POSTSCRIPT)     compile_ps ;;
        NO_POSTSCRIPT)  compile_ps only_dvi;;
        PDF)            compile_pdf;;
        NO_COMPILE) MODE=$PREV_MODE; ;;
        PS2PDF)     compile_ps;
            infon "Creating $file.pdf from $file.ps ... ";
            ps2pdf $file.ps
            ([[ $? -ne 0 ]] && echo -e "${red}Failed!${normal}") ||\
                echo -e "${green}Done!${normal}" ;;
        *)  ;;
    esac

    # The hack to get autocompile mode working continues :(
    if [[ $PREV_MODE = "AUTO_COMPILE" && $COUNT -lt 5 ]]; then
        COUNT=$(( $COUNT+1 ));
        PREV_MODE=$MODE; MODE=AUTO_COMPILE;
        continue;
    elif [[ $PREV_MODE = "AUTO_COMPILE" ]]; then
        continue;
    fi

    [[ $RECURSIVE -eq 0 ]] && break;

    show_menu
    read -n 1 answer; echo;
    case $answer in         # Options arranged alphabetically
    2)      MODE="PS2PDF";;
    [aA])   check inotifywait; PREV_MODE=$MODE; MODE=AUTO_COMPILE;
            info "Autocompile mode ${bold}Enabled${normal}";;
    [dD])   if [[ "$MODE" = "PDF" ]]; then
                MODE="ASK_POSTSCRIPT"; info "Pdf file will not be generated"; sleep 1.5;
            else    MODE="PDF"; info "Pdf file will be generated"; sleep 1.5;
            fi ;;
    [fF])   $PDF_VIEWER $file.pdf >&/dev/null &
            PREV_MODE=$MODE; MODE=NO_COMPILE; ;;
    [lLoO]) if [[ -f "$file.ps" ]]; then 
                $PS_VIEWER $file.ps 2>/dev/null &
                [[ $? -ne 0 ]] && Err "Error in launching ${PS_VIEWER%%\ *}";
            else    Err "$file.ps does not exist!";
            fi 
            PREV_MODE=$MODE; MODE=NO_COMPILE; ;;
    [nN])   break; ;;
    [pP])   if [[ "$MODE" = "POSTSCRIPT" || "$MODE" = "ASK_POSTSCRIPT" ]]; then
                MODE="NO_POSTSCRIPT"; info "Postscript file will not be generated"; sleep 1.5;
            else    MODE="POSTSCRIPT"; info "Postscript file will be automatically generated"; sleep 1.5;
            fi ;;
    [qQ])   if [[ $QUIET ]]; then QUIET=""; echo;
                info "Quiet mode ${bold}disabled${normal}";
            else QUIET=1; echo; info "Quiet mode ${bold}enabled${normal}";
            fi
            PREV_MODE=$MODE; MODE=NO_COMPILE; ;;
    [xX])   if [[ -f "$file.dvi" ]]; then
                $DVI_VIEWER $file.dvi >& /dev/null & # Don't want error messages to mess up terminal
                [[ $? -ne 0 ]] && Err "Error in launching ${DVI_VIEWER}";
            else    Err "$file.dvi does not exist!";
            fi
            PREV_MODE=$MODE; MODE=NO_COMPILE; ;;
    "" | [yY])  continue; ;;
    *)      die "$answer: Invalid Option!"; ;;
    esac

done

