#!/bin/bash

###   This program is used to  compile latex files and output ps/pdf files  ###

###                     Changelog                         ###
# 04/28/2007    Enabled method to convert ps to pdf         #
# 02/??/2007    Enabled an option to support beamer         #
# 01/??/2007    Enabled a "non-stop" mode                   #
# <=01/01/2007  Umpteen number of untracked changes         #

###                         TODO                          ###
# Enable a quiet mode, where only latex errors are shown
#   need to look into --interaction nonstopmode 
#   and make the latex compilation handling more modular

###   Set the colors that will be used   ### {{{
yellow="\E[1;33m"
red="\E[1;31m"
green="\E[1;32m"
underline="\E[4m"
bold="\E[1m"
normal="\E[0m"


# Print out information.
# Usage: info "Whatever you want to print"
info(){
    echo -e "  $yellow *$normal   ${@}";
}

# Print out information without ending with a newline. This adds a space at end
# Usage: infon "Whatever you want to print"
infon(){
    echo -ne "  $yellow *$normal   ${@} ";
}

# Print out error information.
# Usage: Err "Whatever you want to print"
Err(){
    echo -e "  $red *$normal   [$red ERROR!!$normal ] ${@}" >&2;
}

die() {
    Err "$@";
    exit 1;
}
# }}}

DVIPS_PAPER_OPTIONS="-tletter";
PS_VIEWER="gv -watch -spartan"
DVI_VIEWER="xdvi"
PDF_VIEWER="xpdf"
RECURSIVE=0;
LAUNCHED_GV=;
NON_STOP=;
# Possible modes: POSTSCRIPT, ASK_POSTSCRIPT, NO_POSTSCRIPT, PDF : Default is below
MODE="ASK_POSTSCRIPT"; 

help(){ #{{{
    echo;
    echo -e "  $yellow $( basename ${0} ):$normal";
    info "This program is used to compile latex files and output ps/pdf files"
    info "Usage:     $( basename ${0} ) [<options>] [<filename>.tex]";
    info "Options:"
    info "-h | --help            This help text";
    info "-nc| --no-color        Do not use color in output";
    info "-ns| --non-stop        Do not exit program even if there is an error in latex compilation";
    info "-p | --postscript      Assume \"yes\" for postscript output";
    info "-n | --no-postscript   Do not output postscript file";
    info "-d | --pdf             Output a pdf file,- this uses pdflatex";
    info "-r | --recursive       Recursively compile the source";
    info "-b | --beamer          While using beamer, disable -tletter option from dvips"
    info "-a | --acroread        Use acrobat reader as the pdf viewer in lieu of xpdf"
#    info "-q | --quiet           Do not print all the output latex spews out"
    echo;
    info "If no filename is given, then an interactive input prompt is provided";
    echo;
} #}}}


help_read_filename() { #{{{
    info "readfilename -h|--help: == help!!"
    info "readfilename <0|1> [<suffix>]"
    info "${red}BUG!${normal} If a dir is named foo and a file is named fool.bar, then you can enter foo by typing 'foo/.'"
    info "I know how to fix this bug, but it renders the code clumsy and so I won't do it ;)"
    info "Examples of Usage:"
    info "Eg. readfilename 1 tex  == match .tex files in any directory"
    info "Eg. readfilename 0 tex  == match .tex files in current directory only"
    info "Eg. readfilename 0      == match any file in current directory only"
}

## Usage read_filename <0|1> [<suffix>]  -- example: read_filename 1 ogg
read_filename() {
    
    [[ $# -eq 0 ]] && help_read_filename && exit 1;

    ## Declare the following variables
    local filename;
    local INPUT_X;
    local INPUT;
    global FILEPATH;
    local SUFFIX;
    ## Indicate whether we are recursing through directories
    local DIR=$1;
    [[ $# -eq 2 ]] && SUFFIX=".$2" || SUFFIX="";

    ## Remember the old pwd:
    local OLD_PWD=`pwd`
    

  ## Start of outer loop
  while [[ -z $filename || -d $filename ]];
  do
    [[ -d $filename ]] && cd $filename;


    ## Reinitialize all of these to null
    filename="";
    INPUT_X=;
    INPUT=;

    ## clear the screen -- the magic begins from here :)
    clear;
    
    ## Initial list of the file names found
    find ${INPUT_X}*${SUFFIX} -maxdepth 0 -type f -print 2>/dev/null  

    ## Initial list of directories + good looking output
    echo -ne "\n\n-----^^^^${green}Possible files$normal^^^^-----\n\n"
    [[ $DIR -eq 1 ]] && find ${INPUT_X}* -maxdepth 0 -type d -printf "%f\t\t" 2>/dev/null && \
    echo -e "\n\n-----^^^^${yellow}Possible directories${normal}^^^^-----\n\n"
    
    
    ## Do the loop until complete
    while true
    do
        # black on green  -- for completion part
        if [[ ! -z "$INPUT_X" ]]; then
            echo -ne "  $yellow *$normal   Enter the filename [${INPUT_X}\033[00;30;42m${EXT}$normal ?]: ${INPUT_X}"
        elif [[ $DIR -eq 1 ]]; then
            infon "Enter the filename (use .. to go up one directory):"
        else
            infon "Enter the filename:"
        fi

        ## Read each character as it is typed
        read -n 1 INPUT

        ## If input is null, then complete the rest of the stuff and dump it into $filename and exit from this loop
        if [[ -z "$INPUT" && ! -z "$INPUT_X" ]]; then
            filename="${INPUT_X}${EXT}";
            break;
        elif [[ -z "$INPUT" && -z "$INPUT_X" ]]; then
            Err "No filename provided";
            #help_read_filename;
            exit 1;
        fi

        ## else clear the screen for the next best matches
        clear;

        ## Whenever you press a backspace, it sends a non-printable character
        ## delete doesn't work since it sends three (!!) characters and read takes in only one
        if [[ -z `echo -e "$INPUT" | egrep  "[[:print:]]"` ]]; then
            ## If backspace was sent, delete the previous character
            INPUT_X=`echo ${INPUT_X} | head -c -2`
        else
            ## else append the current character to the extended input variable, $INPUT_X
            INPUT_X="${INPUT_X}${INPUT}"
        fi


        ## If the DIR variable is turned on, and we received a .., then go up one directory
        [[ $DIR -eq 1 && "$INPUT_X" = ".." ]] && cd .. && INPUT_X="" && FILEPATH=`pwd`;


        ## Find all the best matches to files and output them
        OUTPUT=`find ${INPUT_X}* -maxdepth 0 -type f -print 2>/dev/null | egrep "${SUFFIX}$"`;
        echo "${OUTPUT}"


        ## If the extended input is non-zero, then we need to find the extension to it.
        if [[ ! -z "${INPUT_X}" ]]; then
            ## If there are no matching files, and DIR is on, then complete dirs instead of files
            if [[ -z "${OUTPUT}" && $DIR -eq 1 ]]; then
                EXT=`find ${INPUT_X}* -maxdepth 0 -type d -print 2>/dev/null | sed -ne "1s:^${INPUT_X}\(.*\)$:\1:p"`
            else
                EXT=`echo "${OUTPUT}" | sed -ne "1s:^${INPUT_X}\(.*\)$:\1:p"`;
            fi
        fi

        ## Again need for some nicely formatted output
        echo -ne "\n\n-----^^^^${green}Possible files$normal^^^^-----\n\n"
        [[ $DIR -eq 1 ]] && find ${INPUT_X}* -maxdepth 0 -type d -printf "%f\t\t" 2>/dev/null && \
        echo -e "\n\n-----^^^^${yellow}Possible directories${normal}^^^^-----\n\n"
        
    done

    ## Completed inner loop, so $filename is either null or has some info in it.
    if [[ -z $FILEPATH ]]; then
        FILEPATH="$filename"
    else
        FILEPATH="$FILEPATH/$filename"
    fi
  done
  ## Completed outer loop here

    ## Return to the dir from which this function was called
    cd "$OLD_PWD"

} #}}}



check() {
    [[ ! -x `which $@` ]] && die "You don't seem to have $@ installed. Is your PATH setup correctly?";
    return 0;
}
    

compile_ps() { #{{{
    info "Creating ${filename%\.*}.ps ...";echo;
    dvips ${DVIPS_PAPER_OPTIONS} -q -o "${filename%\.*}.ps" "${filename%\.*}.dvi";
#    if [[ $LAUNCHED_GV -eq 0 ]]; then
#        infon "Launch ${PS_VIEWER%%\ *}? [enter/n or y]:";
#        read -n 1 answer;echo;
#        if [[ "$answer" = "y" || "$answer" = "Y" ]]; then
#            LAUNCHED_GV=1;
#            $PS_VIEWER "${filename%\.*}.ps" &
#        fi
#    fi
} #}}}

#echo $-
#[[ -z "$1" && ${-/i/} = $- ]] && xterm -hold -e $0 -h && exit

if [[ -n "$@" ]]; then
    for i in "$@"
    do
        case $i in
        -h | --help)        help; exit; ;;
        -nc | --no-color)   unset yellow red green underline bold; ;;
        -ns | --non-stop)   NON_STOP=1; ;;
        -p | --postscript)
            if [[ "$MODE" = "NO_POSTSCRIPT" ]]; then 
                help; die "Can not give -p and -n options together\n";
            else    MODE="POSTSCRIPT";
            fi ;;
        -n | --no-postscript)
            if [[ "$MODE" = "POSTSCRIPT" ]]; then
                help; die "Can not give -p and -n options together\n";
            else    MODE="NO_POSTSCRIPT";
            fi ;;
        -d | --pdf)
            if [[ "$MODE" = "POSTSCRIPT" || "$MODE" = "NO_POSTSCRIPT" ]]; then
                help;  die "Can not give -p or -n, and -d options together\n";
            else check pdflatex && check epstopdf; MODE="PDF"
            fi ;;
        -r | --recursive)   RECURSIVE=1; ;;
        -b | --beamer)      DVIPS_PAPER_OPTIONS="";; 
        -a | --acroread)    PDF_VIEWER="acroread";;
        -*)     help; die "${red}$i${normal}: Invalid Option!\n"; ;;
        *)      filename="$i"; ;;
        esac
    done
fi

# Some error checking
check latex;
[[ "$MODE" = "POSTSCRIPT" || "$MODE" = "ASK_POSTSCRIPT" ]] && check dvips && check "${PS_VIEWER%%\ *}";




if [[ -z ${filename} ]]; then
    read_filename 0 tex;
    filename="$FILEPATH";
    unset FILEPATH;
fi


if [[ ! -f "${filename}" || "${filename/ /}" != "${filename}" ]]; then
    echo; die "${filename} does not exist\n\tHint: Do not enter filenames with spaces in them\n";
fi

# Change to the directory containing the tex file, else a lot of stuff will go awry
cd "$(dirname "$filename")"

while true; do

    case $MODE in
    ASK_POSTSCRIPT)
        latex "${filename}";
        [[ $? -ne 0 && -z "$NON_STOP" ]] && die "${filename}: Error in latex compilation"; 
        echo; infon "CONTINUE with dvips?[enter/y or n]:";
        read -n 1 answer;echo;
        case $answer in
        "" | [yY]*) compile_ps; ;;
        *) ;; # Do nothing
        esac ;;
        
    POSTSCRIPT)
        latex "${filename}";
        [[ $? -ne 0 && -z "$NON_STOP" ]] && die "${filename}: Error in latex compilation";
        compile_ps; ;;

    NO_POSTSCRIPT)
        latex "${filename}";
        [[ $? -ne 0 && -z "$NON_STOP" ]] && die "${filename}: Error in latex compilation"; ;;
        
    PDF) 
        info "Converting the eps images to pdf ..."
        EPSFILES="$(find *.eps -newer ${filename%\.*}.pdf)"
        for i in *.eps; do
            if echo $EPSFILES | grep -q -s $i; then
                info "Converting ${bold}$i${normal} to ${bold}${i%\.*}.pdf${normal}"
                epstopdf $i --outfile="${i%\.*}.pdf"
            fi
        done
        pdflatex "${filename}";
        [[ $? -ne 0 && -z "$NON_STOP" ]] && die "${filename}: pdflatex compilation failed"; ;;

    LAUNCHED_GV) MODE=$LAUNCHED_GV; ;;
    PS2PDF)
        latex "${filename}";
        [[ $? -ne 0 && -z "$NON_STOP" ]] && die "${filename}: Error in latex compilation"; 
        compile_ps;
        info "Creating ${filename%\.*}.pdf from ${filename%\.*}.ps";
        ps2pdf ${filename%\.*}.ps ;;

    *)  ;;
    esac

    [[ $RECURSIVE -eq 0 ]] && break;

    echo; echo;
    info "Want to continue with another compile?"
    info "\
Enter/${green}Y${normal}: Yes\t\t\t\
${green}N${normal}: No\n\t\
${green}P${normal}: Toggle Postscript output\t\
${green}D${normal}: Toggle Pdf Output\n\t\
${green}L${normal}: Launch ${PS_VIEWER%%\ *}\t\t\t\
${green}X${normal}: Launch ${DVI_VIEWER}\n\t\
${green}2${normal}: Toggle PS to PDF output\t\
${green}F${normal}: Launch ${PDF_VIEWER}"
    infon "Give an option ([Y]/N/P/D/L/X):"
    read -n 1 answer; echo;
    case $answer in
    "" | [yY])  continue; ;;
    [nNqQ])   break; ;;
    [pP])   if [[ "$MODE" = "POSTSCRIPT" || "$MODE" = "ASK_POSTSCRIPT" ]]; then
                MODE="NO_POSTSCRIPT"; info "Postscript file will not be generated"; sleep 1.5;
            else    MODE="POSTSCRIPT"; info "Postscript file will be automatically generated"; sleep 1.5;
            fi ;;
    [dD])   if [[ "$MODE" = "PDF" ]]; then
                MODE="ASK_POSTSCRIPT"; info "Pdf file will not be generated"; sleep 1.5;
            else    MODE="PDF"; info "Pdf file will be generated"; sleep 1.5;
            fi ;;
    [lLoO]) if [[ -f "${filename%\.*}.ps" ]]; then 
                $PS_VIEWER ${filename%\.*}.ps 2>/dev/null &
                [[ $? -ne 0 ]] && Err "Error in launching ${PS_VIEWER%%\ *}";
            else    Err "${filename%\.*}.ps does not exist!";
            fi 
            LAUNCHED_GV=$MODE; MODE=LAUNCHED_GV; ;;
    [xX])   if [[ -f "${filename%\.*}.dvi" ]]; then
                $DVI_VIEWER ${filename%\.*}.dvi 2>/dev/null & # Don't want error messages to mess up terminal
                [[ $? -ne 0 ]] && Err "Error in launching ${DVI_VIEWER}";
            else    Err "${filename%\.*}.dvi does not exist!";
            fi
            LAUNCHED_GV=$MODE; MODE=LAUNCHED_GV; ;;
    2)      MODE="PS2PDF";;
    [fF])   $PDF_VIEWER ${filename%\.*}.pdf;;
    *)      die "$answer: Invalid Option!"; ;;
    esac

done


#POSTSCRIPT=0;  # 2 == no postscript, 0 == postscript, but ask confirmation, 1 == compile to ps directly.
#PDF=0;         # 0 == no pdf, 1 == pdf on
#  Read the latex filename from interactive input ##{{{
#read_filename() {
#    clear;
#    ls -1 | sed -ne "/^${INPUT_X}\(.*\)\.tex$/p"
#    echo -e "\n\n\n$green^$normal---------------${green}Possible latex files$normal----------------------$green^\n\n\n$normal"
#
#    while true
#    do
#        # black on green
#        if [[ ! -z "$INPUT_X" ]]; then
#            echo -ne "  $yellow *$normal   Enter the latex filename [${INPUT_X}\033[00;30;42m${EXT}$normal ?]: ${INPUT_X}"
#        else
#            infon "Enter the latex filename:"
#        fi
#
#        read -n 1 INPUT
#
#        if [[ -z "$INPUT" && ! -z "$INPUT_X" ]]; then
#            filename="${INPUT_X}${EXT}";
#            break;
#        elif [[ -z "$INPUT" && -z "$INPUT_X" ]]; then
#            Err "No filename provided";
#            help;
#            exit 1;
#        fi
#
#        clear;
#
#        if [[ -z `echo -e "$INPUT" | grep -e "[[:print:]]"` ]]; then
#            INPUT_X=`echo ${INPUT_X} | head -c -2`
#        else
#            INPUT_X="${INPUT_X}${INPUT}"
#        fi
#
#        OUTPUT=`ls -1 | sed -ne "/^${INPUT_X}/p" | sed -ne "/\.tex$/p"`
#        if [[ ! -z "${INPUT_X}" ]]; then
#            echo "${OUTPUT}"
#            EXT=`echo "${OUTPUT}" | head -n 1 | sed -e "s/^${INPUT_X}\(.*\)$/\1/"`;
#        else
#            #ls -1 | sed -ne "/^${INPUT_X}\(.*\)\.tex$/p"
#            echo "${OUTPUT}"
#        fi
#            
#        echo -e "\n\n\n$green^$normal---------------${green}Possible latex files$normal----------------------$green^\n\n\n$normal"
#        
#    done
#} #}}}
