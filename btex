#!/bin/bash

###   This program is used to  compile latex files and output ps/pdf files  ###

        ###                     Changelog                         ###
        # 03/31/2008    Enabled inverse search for all latex files  #
        #               through the -src-specials command option    #
        #               This means that srcltx is not reqd. now     # 
        #               Rewrote help and provided command line opt. #
        # 02/28/2008    Fixed bugs in set_xdvi which was being used #
        #               to enable inverse search in xdvi            #
        #               Fixed bugs in autocompile WAITTIME          #
        #               Disabled autocompile option if inotifywait  #
        #               is not available                            #
        # 02/26/2008    Enabled inverse search through xdvi & gvim  #
        # 12/30/2007    Code rearrangement and                      #
        #               FULL autocompile mode! :D                   #
        # 12/25/2007    Allow one to execute it by clicking on the  #
        #               file in rox                                 #
        #               Better help text                            #
        # 12/20/2007    Amazing article online enables me to get    #
        #               the status of each part of a pipe, so now   #
        #               error checking works very nice even with    #
        #               the grep command (in QUIET mode)            #
        # 11/24/2007    Rudimentary autocompile mode                #
        # 11/20/2007    Pretty output :P                            #
        #               New pattern for grep to capture more errors #
        # 10/10/2007    Enabled a quiet mode (reduces junk o/p)     #
        #               Enabled Toggling the quiet mode             #
        #               Reorganized menu and help text              #
        # 04/28/2007    Enabled method to convert ps to pdf         #
        # 02/??/2007    Enabled an option to support beamer         #
        # 01/??/2007    Enabled a "non-stop" mode                   #
        # <=01/01/2007  Umpteen number of untracked changes         #
        #-----------------------------------------------------------#

        ###                         TODO (04/28/2007)             ###
        # Enable a quiet mode, where only latex errors are shown    #
        #   need to look into --interaction nonstopmode             #
        #   and make the latex compilation handling more modular    #
        # The above is done, but without --interaction nonstopmode  #
        # would be interesting to see if it can be improved.        #
        #                                                           #
        # Enable an auto mode, where the latex file will be         #
        # automatically compiled whenever the timestamp of the tex  #
        # file changes  --- DONE!                                   #
        #-----------------------------------------------------------#

###   Set the colors that will be used   ### {{{
yellow="\E[1;33m"
red="\E[1;31m"
green="\E[1;32m"
blue="\E[1;34m"
underline="\E[4m"
bold="\E[1m"
normal="\E[0m"


# Print out information.
# Usage: info "Whatever you want to print"
info(){
    echo -e "  $yellow *$normal   ${@}";
}

# Print out information without ending with a newline. This adds a space at end
# Usage: infon "Whatever you want to print"
infon(){
    echo -ne "  $yellow *$normal   ${@} ";
}

# Print out error information.
# Usage: Err "Whatever you want to print"
Err(){
    echo -e "  $red *$normal   [$red ERROR!!$normal ] ${@}" >&2;
}

die() {
    Err "$@";
    exit 1;
}
# }}}

check() {
    local INFO=die;
    [[ $2 ]] && INFO=$2;
    [[ ! -x `which $1 2>/dev/null` ]] && \
    $INFO "You don't seem to have $1 installed. Is your PATH setup correctly?"\
    && return 1;
    CHECKED=`which $1`
    return 0;
}
    
DVIPS_PAPER_OPTIONS="-tletter";
check gv && PS_VIEWER="$CHECKED -watch -spartan"
check xdvi && DVI_VIEWER="$CHECKED"
check xpdf && PDF_VIEWER="$CHECKED"
gvim_server=;
RECURSIVE=0;
NON_STOP=;
QUIET=;
COUNT=1;
INVERSE_SEARCH=;
# Possible modes: PS2PDF, POSTSCRIPT, ASK_POSTSCRIPT, NO_POSTSCRIPT, PDF
# Default is below
MODE="ASK_POSTSCRIPT"; 

help(){ #{{{
    echo;
    echo -e "  $yellow $( basename ${0} ):$normal";
    info "This program is used to compile latex files and output ps/pdf files"
    info "Usage:     $( basename ${0} ) [<options>] [<filename>.tex]";
    info "Options:"
    info "-a | --acroread        Use acrobat reader as pdf viewer in lieu of xpdf"
    info "-b | --beamer          Beamer mode: disable $DVIPS_PAPER_OPTIONS option in dvips"
    info "-d | --pdf             Output a pdf file,- this uses pdflatex";
    info "-h | --help            This help text";
    info "-i | --inv-search      Enable inverse search in dvi";
    info "-n | --no-postscript   Do not output postscript file";
    info "-nc| --no-color        Do not use color in output";
    info "-ns| --non-stop        Do not exit program even if latex gives errors"
    info "-p | --postscript      Assume \"yes\" for postscript output";
    info "-pd| --ps2pdf          Generate pdf from postscript output";
    info "-q | --quiet           Do not print all the output latex spews out"
    info "-r | --recursive       Recursively compile the source. Otherwise
                              the program will compile once and exit";
    echo;
    info "${bold}Inverse search:$normal
      - Inverse search is the feature by which one can access the
        corresponding line in an editor by clicking in the viewer (used to
        view the latex output).
      - In this script, inverse search feature can be used if one is using
        gvim and the tex file is open in a gvim editor. The script
        automatically determines the correct gvim if multiple gvims are running.
      - The dvi viewer which is automatically set up by this script is xdvi.
        Other dvi viewers will need to be configured separately.
      - If you use okular, then inverse search may be possible even in 
        pdf files." 
    echo;
    info "If multiple -d,-n,-p,-pd are given then the last one will be used";
    echo;
    info "If no filename is given, then an interactive input prompt is provided
    ${underline}An example, when using beamer${normal}:
    btex -b -d -r -q -ns # recursive, quiet, nonstop, using pdflatex & beamer";
    echo;
} #}}}


help_read_filename() { #{{{
    info "readfilename -h|--help: == help!!"
    info "readfilename <0|1> [<suffix>]"
    info "${red}BUG!${normal} If a dir is named foo and a file is named fool.bar, then you can enter foo by typing 'foo/.'"
    info "I know how to fix this bug, but it renders the code clumsy and so I won't do it ;)"
    info "Examples of Usage:"
    info "Eg. readfilename 1 tex  == match .tex files in any directory"
    info "Eg. readfilename 0 tex  == match .tex files in current directory only"
    info "Eg. readfilename 0      == match any file in current directory only"
}

## Usage read_filename <0|1> [<suffix>]  -- example: read_filename 1 ogg
read_filename() {
    
    [[ $# -eq 0 ]] && help_read_filename && exit 1;

    ## Declare the following variables
    local filename;
    local INPUT_X;
    local INPUT;
    global FILEPATH;
    local SUFFIX;
    ## Indicate whether we are recursing through directories
    local DIR=$1;
    [[ $# -eq 2 ]] && SUFFIX=".$2" || SUFFIX="";

    ## Remember the old pwd:
    local OLD_PWD=`pwd`
    

  ## Start of outer loop
  while [[ -z $filename || -d $filename ]];
  do
    [[ -d $filename ]] && cd $filename;


    ## Reinitialize all of these to null
    filename="";
    INPUT_X=;
    INPUT=;

    ## clear the screen -- the magic begins from here :)
    clear;
    
    ## Initial list of the file names found
    find ${INPUT_X}*${SUFFIX} -maxdepth 0 -type f -print 2>/dev/null  

    ## Initial list of directories + good looking output
    echo -ne "\n\n-----^^^^${green}Possible files$normal^^^^-----\n\n"
    [[ $DIR -eq 1 ]] && find ${INPUT_X}* -maxdepth 0 -type d -printf "%f\t\t" 2>/dev/null && \
    echo -e "\n\n-----^^^^${yellow}Possible directories${normal}^^^^-----\n\n"
    
    
    ## Do the loop until complete
    while true
    do
        # black on green  -- for completion part
        if [[ ! -z "$INPUT_X" ]]; then
            echo -ne "  $yellow *$normal   Enter the filename [${INPUT_X}\033[00;30;42m${EXT}$normal ?]: ${INPUT_X}"
        elif [[ $DIR -eq 1 ]]; then
            infon "Enter the filename (use .. to go up one directory):"
        else
            infon "Enter the filename:"
        fi

        ## Read each character as it is typed
        read -n 1 INPUT

        ## If input is null, then complete the rest of the stuff and dump it into $filename and exit from this loop
        if [[ -z "$INPUT" && ! -z "$INPUT_X" ]]; then
            filename="${INPUT_X}${EXT}";
            break;
        elif [[ -z "$INPUT" && -z "$INPUT_X" ]]; then
            Err "No filename provided";
            #help_read_filename;
            exit 1;
        fi

        ## else clear the screen for the next best matches
        clear;

        ## Whenever you press a backspace, it sends a non-printable character
        ## delete doesn't work since it sends three (!!) characters and read takes in only one
        if [[ -z `echo -e "$INPUT" | egrep  "[[:print:]]"` ]]; then
            ## If backspace was sent, delete the previous character
            INPUT_X=`echo ${INPUT_X} | head -c -2`
        else
            ## else append the current character to the extended input variable, $INPUT_X
            INPUT_X="${INPUT_X}${INPUT}"
        fi


        ## If the DIR variable is turned on, and we received a .., then go up one directory
        [[ $DIR -eq 1 && "$INPUT_X" = ".." ]] && cd .. && INPUT_X="" && FILEPATH=`pwd`;


        ## Find all the best matches to files and output them
        OUTPUT=`find ${INPUT_X}* -maxdepth 0 -type f -print 2>/dev/null | egrep "${SUFFIX}$"`;
        echo "${OUTPUT}"


        ## If the extended input is non-zero, then we need to find the extension to it.
        if [[ ! -z "${INPUT_X}" ]]; then
            ## If there are no matching files, and DIR is on, then complete dirs instead of files
            if [[ -z "${OUTPUT}" && $DIR -eq 1 ]]; then
                EXT=`find ${INPUT_X}* -maxdepth 0 -type d -print 2>/dev/null | sed -ne "1s:^${INPUT_X}\(.*\)$:\1:p"`
            else
                EXT=`echo "${OUTPUT}" | sed -ne "1s:^${INPUT_X}\(.*\)$:\1:p"`;
            fi
        fi

        ## Again need for some nicely formatted output
        echo -ne "\n\n-----^^^^${green}Possible files$normal^^^^-----\n\n"
        [[ $DIR -eq 1 ]] && find ${INPUT_X}* -maxdepth 0 -type d -printf "%f\t\t" 2>/dev/null && \
        echo -e "\n\n-----^^^^${yellow}Possible directories${normal}^^^^-----\n\n"
        
    done

    ## Completed inner loop, so $filename is either null or has some info in it.
    if [[ -z $FILEPATH ]]; then
        FILEPATH="$filename"
    else
        FILEPATH="$FILEPATH/$filename"
    fi
  done
  ## Completed outer loop here

    ## Return to the dir from which this function was called
    cd "$OLD_PWD"

} #}}}


set_xdvi() { # {{{
    # Enter gvim --remote here:
    #   determine if only one gvim is running, if so take that as the remote
    #   else: check to see if multiple gvim's are running
    #       if yes: check to see if the $file has servername with its gvim
    #       else:   discard all lines with servername
    #               check the order $o of the $file in ps output => GVIM$o
    #       else:   file is not open, can't do anything.
    #   else: file is not open, can't do anything.
    [[ ${DVI_VIEWER/xdvi/} = $DVI_VIEWER ]] && return
    TMP_FILE=`mktemp`
    ps -u $USER -o command | grep ^gvim  > $TMP_FILE

    if grep "$file" $TMP_FILE | grep -q "\-\-servername"; then
        gvim_server=`grep "$file" $TMP_FILE | sed -ne "s@^.*\-\-servername \([[:alnum:]]*\) .*$@\1@p"`
    elif grep -q "$file" $TMP_FILE; then
        gvim_server=`grep -n "$file" $TMP_FILE`;
        gvim_server=${gvim_server%%:*};
        gvim_server=`gvim --serverlist | tail -n +$gvim_server | head -n 1`;
    fi
    rm -f $TMP_FILE
}
# }}}

#echo $-
[[ $DISPLAY && -z "$@" ]] && ! tty -s && ( xterm -hold -e $0 -h && exit )

until [[ -z "$1" ]]; do
    case $1 in
    -h | --help)        help; exit; ;;
    -nc| --no-color)    unset yellow red green underline bold; ;;
    -ns| --non-stop)    NON_STOP=1; ;;
    -p | --postscript)  MODE="POSTSCRIPT";;
    -pd| --ps2pdf)      MODE="PS2PDF";;
    -n | --no-postscript) MODE="NO_POSTSCRIPT";;
    -d | --pdf)         MODE="PDF";;
    -r | --recursive)   RECURSIVE=1; ;;
    -b | --beamer)      DVIPS_PAPER_OPTIONS="";; 
    -a | --acroread)    check acroread && PDF_VIEWER="$CHECKED";;
    -q | --quiet)       QUIET=1;;
    -i | --inv-search)  INVERSE_SEARCH="-src-specials";;
    -*) help; die "${red}$1${normal}: Invalid Option!\n"; ;;
    *)  filename="$1"; ;;
    esac
    shift
done

show_menu() { # {{{
    echo; echo;

    infon "${bold}Current mode$normal:${blue}"
    case $MODE in
        ASK_POSTSCRIPT) echo -ne "\tPostscript file is generated after confirmation";;
        NO_POSTSCRIPT)  echo -ne "\tOnly DVI file is generated";;
        POSTSCRIPT)     echo -ne "\tPostscript file is automatically generated";;
        PS2PDF)         echo -ne "\tPDF file is generated from PS, using ps2pdf";;
        PDF)            echo -ne "\tPDF file is generated using pdflatex";;
    esac
    ([[ $INVERSE_SEARCH ]] && echo -e "\n\t\t\tInverse search is enabled" ) || echo;
    infon "Want to continue with another compile?\n
\tEnter/${green}Y${normal}: Yes (Repeat compile)\t\
${green}N${normal}: No (Quit)\n\t\
${green}P${normal}: Toggle Postscript output\t\
${green}L${normal}: Launch ${PS_VIEWER%%\ *}\n\t\
${green}D${normal}: Toggle Pdf Output\t\t\
${green}X${normal}: Launch ${DVI_VIEWER}\n\t\
${green}2${normal}: Toggle PS to PDF output\t\
${green}F${normal}: Launch ${PDF_VIEWER}\n\t\
${green}Q${normal}: Toggle Quiet mode\t\t\
${green}I${normal}: Toggle Inverse search\n"
    [[ $INOTIFYWAIT ]] && echo -ne "\t${green}A${normal}: Enable Autocompile mode\n"
    infon "Give an option ([Y]/N/P/D/L/X/Q/A):"
}
# }}}

success() {
    ([[ $1 -ne 0 ]] && echo -e "${red}Failed!${normal}") ||\
        echo -e "${green}Done!${normal}";
}

compile_ps() { #{{{
    if [[ $QUIET ]]; then
        latex $INVERSE_SEARCH "${filename}"  >&1 | grep --color -A 11 '^! .*';
        # echo ${PIPESTATUS[@]} gives the exit status of each part of pipe
        [[ ${PIPESTATUS[0]} -ne 0 && -z "$NON_STOP" ]] && \
            die "${filename}: Error in latex compilation"; 
    else
        latex $INVERSE_SEARCH "${filename}"
        [[ $? -ne 0 && -z "$NON_STOP" ]] && \
            die "${filename}: Error in latex compilation"; 
    fi

    case $1 in
        ask)echo; infon "CONTINUE with dvips?[enter/y or n]:";
            read -n 1 answer;echo;;
        only_dvi) answer="n";;
        *)  answer="y";;
    esac
    case $answer in
        "" | [yY]*) infon "Creating $file.ps ... ";#echo;
            dvips ${DVIPS_PAPER_OPTIONS} -q -o "$file.ps" "$file.dvi"
            success $? ;;
        *) ;; # Do nothing
    esac
} #}}}

compile_pdf() { # {{{
    info "Converting the (newer) eps images to pdf ..."
    find *.eps 2>/dev/null | while read i; do
        if [[ "${i%\.*}.pdf" -ot "$i" ]]; then
            infon "Converting ${bold}$i${normal} to ${bold}${i%\.*}.pdf${normal} ... "
            epstopdf $i --outfile="${i%\.*}.pdf"
            success $?
        fi
    done
    if [[ "$QUIET" ]]; then
        pdflatex $INVERSE_SEARCH "${filename}" >&1 | grep --color -A 11 '^! .*' -;
        # echo ${PIPESTATUS[@]} gives the exit status of each part of pipe
        [[ ${PIPESTATUS[0]} -ne 0 && -z $NON_STOP ]] && \
            die "${filename}: pdflatex compilation failed"
    else
        pdflatex $INVERSE_SEARCH "$filename"
        [[ $? -ne 0 && -z $NON_STOP ]] && \
            die "${filename}: pdflatex compilation failed"
    fi
}
# }}}

compile() { # {{{
    case $1 in
        ASK_POSTSCRIPT) compile_ps ask ;;
        POSTSCRIPT)     compile_ps ;;
        NO_POSTSCRIPT)  compile_ps only_dvi;;
        PDF)        compile_pdf;;
        PS2PDF)     compile_ps;
            infon "Creating $file.pdf from $file.ps ... ";
            ps2pdf $file.ps
            success $?;;
        *)  ;;
    esac
} # }}}

autocompile() { # {{{
    local MODE=$1;
    local TOTAL=$2;
    #local WAITTIME=$3;     # WAITTIME should be already set
    for (( i=1; i<=$TOTAL; i+=1 )); do
        echo -ne "  ${blue} *   Waiting$normal for change in the status of file ...\r"
        if $INOTIFYWAIT -t $WAITTIME -qq ${filename}; then
        # Use above line if you want to break out of autocompile after some
        # time, say 300s, if no modifications are made for 300s.
        # Otherwise use following line
        #if inotifywait -qq ${filename}; then
            info "Autocompile # $i/$TOTAL                                   "
            compile $MODE
        else
            info "${red}Abort autocompile${normal}: No change in status of file for over $WAITTIME seconds"
            return
        fi
    done
}
# }}}

# Some error checking
check latex;
[[ "$MODE" = "POSTSCRIPT" || "$MODE" = "ASK_POSTSCRIPT" ]] && check dvips;
[[ "$MODE" = "PDF" ]] && check pdflatex && check epstopdf;


if [[ -z ${filename} ]]; then
    read_filename 0 tex;
    filename="$FILEPATH";
    unset FILEPATH;
fi


if [[ ! -f "${filename}" || "${filename/ /}" != "${filename}" ]]; then
    echo; die "${filename} does not exist\n\tHint: Do not enter filenames with spaces in them\n";
fi

# Change to the directory containing the tex file, else a lot will go awry
cd "$(dirname "$filename")"
file="${filename%\.*}";

# Compile the file with command line parameters
compile $MODE
[[ $RECURSIVE -eq 0 ]] && exit;

# Set XDVI if possible
set_xdvi

# Check for the presence of inotifywait
if check inotifywait Err; then
    INOTIFYWAIT=$CHECKED;
else
    Err "${bold}inotifywait${normal} not found. Autocompile mode will be disabled";
fi

# Now, enter recursion
while true; do

    show_menu
    read -n 1 answer; echo;
    case $answer in         # Options arranged alphabetically
    2)      MODE="PS2PDF"; compile "PS2PDF";;
    [aA])   [[ -z $INOTIFYWAIT ]] && check inotifywait && INOTIFYWAIT="$CHECKED"
            info "Autocompile mode ${bold}Enabled${normal}";
            infon "No. of times you want to compile automatically [default: 5]:"
            read answer; [[ $answer -gt 0 ]] || answer=5;
            infon "No. of secs of wait-time before autocompile aborts [default: 300]:"
            read WAITTIME; [[ $WAITTIME && $WAITTIME -ge 0 ]] || WAITTIME=300;
            autocompile $MODE $answer;;
    [dD])   if [[ "$MODE" = "PDF" ]]; then
                MODE="ASK_POSTSCRIPT"; 
                info "Pdf file will not be generated"; sleep 1.5;
                compile $MODE;
            else    
                MODE="PDF";
                info "Pdf file will be generated using pdflatex"; sleep 1.5;
                compile $MODE;
            fi ;;
    [fF])   $PDF_VIEWER $file.pdf >&/dev/null & ;;
    [lLoO]) if [[ -f "$file.ps" ]]; then 
                $PS_VIEWER $file.ps 2>/dev/null &
                [[ $? -ne 0 ]] && Err "Error in launching ${PS_VIEWER%%\ *}";
            else    Err "$file.ps does not exist!";
            fi ;;
    [iI])   if [[ $INVERSE_SEARCH ]]; then
                INVERSE_SEARCH=; gvim_server=; echo;
                info "Disabling inverse search during compilation. Restart ${DVI_VIEWER##*\/}.";
                sleep 1.5;
            else
                INVERSE_SEARCH="-src-specials"; echo;
                set_xdvi;
                info "Enabling inverse search during compilation.  Restart ${DVI_VIEWER##*\/}";
                [[ ${DVI_VIEWER/xdvi/} = $DVI_VIEWER ]] &&\
                info "You will need to configure ${DVI_VIEWER##*\/} to use this feature";
                sleep 1.5;
            fi;;
    [nN])   break; ;;
    [pP])   if [[ "$MODE" = "POSTSCRIPT" || "$MODE" = "ASK_POSTSCRIPT" ]]; then
                MODE="NO_POSTSCRIPT";
                info "Postscript file will not be generated"; sleep 1.5;
                compile $MODE
            else    
                MODE="POSTSCRIPT"; 
                info "Postscript file will be automatically generated"; sleep 1.5;
                compile $MODE
            fi ;;
    [qQ])   if [[ $QUIET ]]; then QUIET=""; echo;
                info "Quiet mode ${bold}disabled${normal}";
            else QUIET=1; echo; info "Quiet mode ${bold}enabled${normal}";
            fi ;;
    [xX])   if [[ -f "$file.dvi" ]]; then
                # dvips error messages should not mess up terminal
                if [[ $gvim_server ]]; then
                    # gvim_server is nonempty if xdvi is used
                    $DVI_VIEWER -editor \
                        "gvim --servername $gvim_server --remote +%l %f" \
                        $file.dvi >& /dev/null &
                else
                    $DVI_VIEWER $file.dvi >& /dev/null &
                fi
                [[ $? -ne 0 ]] && Err "Error in launching ${DVI_VIEWER}";
            else    Err "$file.dvi does not exist!";
            fi ;;
    "" | [yY])  compile $MODE ;;
    *)      die "$answer: Invalid Option!"; ;;
    esac

done

